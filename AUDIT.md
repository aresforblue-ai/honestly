# Audit Readiness (ZK + API)

This doc packages the essentials for an external cryptographic/security audit (e.g., Trail of Bits, Zellic).

## Scope

- ZK circuits: `age`, `authenticity`, `age_level3`, `Level3Inequality` (Groth16, bn128/BLS12-381, Poseidon hash, depth 16).
- Prover/Verifier: `backend-python/zkp/snark-runner.js` (snarkjs), verification keys served at `/zkp/artifacts/...` with ETag/sha256 integrity gates (`INTEGRITY.json`).
- API surface: FastAPI REST `/vault/*`, GraphQL `/graphql`, static `/zkp/artifacts`.
- Data store: Neo4j (minimal mode), optional Kafka/Postgres disabled in `docker-compose.min.yml`.

## Artifact fingerprints (fill before audit)

### Computing SHA256 Checksums

**On Linux/macOS**:

```bash
cd backend-python/zkp
sha256sum artifacts/common/pot16_final.ptau
sha256sum artifacts/age/age.r1cs
sha256sum artifacts/age/age_final.zkey
sha256sum artifacts/age/verification_key.json
sha256sum artifacts/authenticity/authenticity.r1cs
sha256sum artifacts/authenticity/authenticity_final.zkey
sha256sum artifacts/authenticity/verification_key.json
```

**On Windows (PowerShell)**:

```powershell
cd backend-python\zkp
Get-FileHash artifacts\common\pot16_final.ptau -Algorithm SHA256
Get-FileHash artifacts\age\age.r1cs -Algorithm SHA256
Get-FileHash artifacts\age\age_final.zkey -Algorithm SHA256
Get-FileHash artifacts\age\verification_key.json -Algorithm SHA256
Get-FileHash artifacts\authenticity\authenticity.r1cs -Algorithm SHA256
Get-FileHash artifacts\authenticity\authenticity_final.zkey -Algorithm SHA256
Get-FileHash artifacts\authenticity\verification_key.json -Algorithm SHA256
```

**Using Node.js**:

```bash
cd backend-python/zkp
node -e "const fs = require('fs'); const crypto = require('crypto'); const files = ['artifacts/common/pot16_final.ptau', 'artifacts/age/age.r1cs', 'artifacts/age/age_final.zkey', 'artifacts/age/verification_key.json', 'artifacts/authenticity/authenticity.r1cs', 'artifacts/authenticity/authenticity_final.zkey', 'artifacts/authenticity/verification_key.json']; files.forEach(f => { try { const data = fs.readFileSync(f); const hash = crypto.createHash('sha256').update(data).digest('hex'); console.log(`${f}: ${hash}`); } catch(e) { console.log(`${f}: FILE_NOT_FOUND`); } });"
```

### Artifact Checksums

**⚠️ IMPORTANT**: After rebuilding circuits (`make zkp-rebuild` or `rebuild-circuits.ps1 -All`), compute and fill in these checksums or run `python scripts/verify_key_integrity.py` (writes `INTEGRITY.json`).

**Powers of Tau**:

- `artifacts/common/pot16_final.ptau` — SHA256: `1c401abb57c9ce531370f3015c3e75c0892e0f32b8b1e94ace0f6682d969f34f`
  - **Verify**: `curl -L https://storage.googleapis.com/zkevm/ptau/powersOfTau28_hez_final_16.ptau | sha256sum`

**Age Circuit**:

- `artifacts/age/age.r1cs` — SHA256: `e0404cc5146d5b7aee5017ecb7850461763e8ea7142948ac0e13747e28e093a7`
- `artifacts/age/age_final.zkey` — SHA256: `2b231ea59185f9b9d17dde708d8ffbf37529e822d397cd13c923a826e6858069`
- `artifacts/age/verification_key.json` — SHA256: `2eda87af259390d9114757aefecc1e9f2701ca07e37652214b1cbf2a67b7b32b`
- **Public Signals Order**: `["minAgeOut", "referenceTsOut", "documentHashOut", "commitment", "nullifier"]`

**Authenticity Circuit**:

- `artifacts/authenticity/authenticity.r1cs` — SHA256: `f00d54b1a1445d2a541bd292694d3ed78501e3cdc765bb878f0c1c29fb30b79c`
- `artifacts/authenticity/authenticity_final.zkey` — SHA256: `7552e2d800781616935961352af83ebc4bc3313b6297b504a348fd4c090980cf`
- `artifacts/authenticity/verification_key.json` — SHA256: `8fd32737e1005168bee209073843366b11b25f47c63819c293692cbcd20874ce`
- **Public Signals Order**: `["rootOut", "leafOut", "epochOut", "nullifier"]`

**Level3 Age Circuit**:

- `artifacts/level3/age_level3.r1cs` — SHA256: `0f8c1df677ce234a403d31a85e44531153ad4cfc61ceefe0d866a02845f60df3`
- `artifacts/level3/age_level3_final.zkey` — SHA256: `46f6780e75a11f1ef2acefaf325f9e8912d58b1c0df2cbd34e3e9cdf02525e94`
- `artifacts/level3/verification_key.json` — SHA256: `14ab009bcc36108538beba2152d29f19297e6b3548b3020efb6ce3005a20ae8e`
- **Public Signals Order**: `["referenceTs", "minAge", "userID", "documentHash", "nullifier"]`

**Level3 Inequality Circuit**:

- `artifacts/level3/Level3Inequality.r1cs` — SHA256: `997ef751a1203383a64ef6bd29ef2c35ccbfa1070f24ddfdacb3ace757ab6ff2`
- `artifacts/level3/Level3Inequality_final.zkey` — SHA256: `a1f7d6cdc98d7578f043b0682ff7db014792c3cd5c41d251d63bdbc3618e6471`
- `artifacts/level3/verification_key.json` — SHA256: `854fe0421011f58ea4907bb1a8d696b849365191978e82c812f607c74aaaa21b`
- **Public Signals Order**: see `backend-python/zkp/circuits/inequality_level3.circom`.

**Integrity Manifest**:

- `artifacts/INTEGRITY.json` — SHA256: `56543a1557715f15900c9a0ff9071fd23de304bbaf68e05b8b48247d3972725e` (generated by `scripts/verify_key_integrity.py`)

**Hosting**: vkeys served at `/zkp/artifacts/{age,authenticity,level3}/verification_key.json` (enable gzip/cache at proxy).

### Sample Proof Checksums

After generating sample proofs (see below), compute checksums:

```bash
# Age proof
sha256sum artifacts/age/age-proof.sample.json
# Expected: <fill after generation>

# Authenticity proof
sha256sum artifacts/authenticity/authenticity-proof.sample.json
# Expected: <fill after generation>
```

**Note**: Replace `<fill after build>` and `<fill after generation>` with actual checksums before audit submission.

## Reproducible ZK build

From `backend-python/zkp`:

```bash
npm install
make zkp-rebuild
# or on Windows: ./rebuild-circuits.ps1 -All

# Generate integrity manifest (included in make target)
python scripts/verify_key_integrity.py

# If compiling/proving level3 locally, increase Node heap to avoid OOM:
export NODE_OPTIONS="--max-old-space-size=8192"
```

CI: `.github/workflows/zkp.yml` rebuilds circuits, regenerates integrity hashes, and runs zk property tests on circuit changes (with `ZK_TESTS=1`).

## Sample proofs

Run:

```bash
node snark-runner.js prove age --input-file ./samples/age-input.sample.json > ./samples/age-proof.sample.json
node snark-runner.js verify age --proof-file ./samples/age-proof.sample.json
node snark-runner.js prove authenticity --input-file ./samples/authenticity-input.sample.json > ./samples/authenticity-proof.sample.json
node snark-runner.js verify authenticity --proof-file ./samples/authenticity-proof.sample.json
# Level3 (optional, requires inputs)
node snark-runner.js prove age_level3 --input-file ./samples/age-level3-input.sample.json > ./samples/age-level3-proof.sample.json
node snark-runner.js verify age_level3 --proof-file ./samples/age-level3-proof.sample.json
```

Replace placeholder vkeys/proofs with generated ones before audit. Include checksums of `ptau`, `r1cs`, `zkey`, `verification_key.json`, `INTEGRITY.json`, and sample proofs.

### Sample Proof Checksums (fill after generation)

After running the proof generation commands above:

**Age Proof**:

- `samples/age-proof.sample.json` — SHA256: `<fill after generation>`
- `samples/age-input.sample.json` — SHA256: `<fill after generation>`

**Authenticity Proof**:

- `samples/authenticity-proof.sample.json` — SHA256: `<fill after generation>`
- `samples/authenticity-input.sample.json` — SHA256: `<fill after generation>`

**Level3 Age Proof (optional)**:

- `samples/age-level3-proof.sample.json` — SHA256: `<fill after generation>`
- `samples/age-level3-input.sample.json` — SHA256: `<fill after generation>`

Public signal order:

- age: `[minAgeOut, referenceTsOut, documentHashOut, commitment, nullifier]`
- authenticity: `[rootOut, leafOut, epochOut, nullifier]`
- age_level3: `[referenceTs, minAge, userID, documentHash, nullifier]`

## Environment and security posture (audit deployment)

- Minimal stack: `docker-compose.min.yml` (API + Neo4j + frontend + ConductMe Core). Kafka/Postgres disabled.
- CORS: `ALLOWED_ORIGINS` must be set; `STRICT_CORS=true` to fail fast if unset; `ENABLE_CORS=true`.
- Auth: JWT/OIDC (JWKS RS/ES) with HS256 fallback; API key for `/ai/*`; bundle endpoint is public but rate-limited.
- Rate limiting: configure Redis-backed limiter in prod; defaults cover `/vault/share` and `/zkp/artifacts`. Tune via `RATE_LIMIT_WINDOW`, `RATE_LIMIT_MAX`, `RATE_LIMIT_PATHS`.
- Security headers: `ENABLE_SECURITY_HEADERS=true` adds nosniff, frame deny, referrer policy, HSTS (HTTPS only).
- Static vkeys: served at `/zkp/artifacts/...` (cacheable; gzip at proxy) with integrity checks (`INTEGRITY.json`).
- Vault key: loaded via KMS/env/file; `ALLOW_GENERATED_VAULT_KEY=true` only for dev.

## Verification flow

- Backend: proofs can be verified via snark-runner (Node) callable from Python; API currently serves bundles and vkeys, with verification typically client-side.
- Frontend: snarkjs verify using fetched vkey and bundle `{proof, publicSignals, circuit}`; expects public signal order above.

## DAST / negative tests
- ZAP baseline:
  ```bash
  docker run --rm -t owasp/zap2docker-stable zap-baseline.py -t https://staging.yourdomain -r zap-baseline.html
  ```
- ZAP full:
  ```bash
  docker run --rm -t -v $(pwd):/zap/wrk owasp/zap2docker-stable zap-full-scan.py -t https://staging.yourdomain -r zap-full.html
  ```
- Abuse cases:
  - Malformed JSON → expect 400, no stack trace.
  - Rate-limit bypass on `/vault/share/{token}/bundle` → expect 429 and recovery, no resource exhaustion.
  - Headers: `X-Content-Type-Options`, `X-Frame-Options`, `Referrer-Policy`, `Strict-Transport-Security` (HTTPS).

## Performance (target p99 < 200ms)
- k6 script at `tests/perf/k6-load.js`:
  ```bash
  BASE_URL=https://staging.yourdomain AUTH="Bearer ..." k6 run tests/perf/k6-load.js
  ```
  Scenarios: ramp to 100 VUs (5m hold), spike 10→500 VUs. Thresholds: `p(99)<200ms`, error rate <1%.
- Capture and attach k6 summary (p95/p99, errors). Optimize vkey caching/bundle size if over budget.

## Chaos drills
- Kill Redis (rate limiter) during load; expect graceful 429/503 and automatic recovery on return.
- Kill Neo4j; expect health/readiness to fail, dependent routes 503, and auto-reconnect when back.

## Audit handoff bundle
- This `AUDIT.md`.
- Checksums file for ptau/r1cs/zkey/vkey and sample proofs.
- Sample proofs + public signals (valid).
- k6 report, ZAP report.
- Lockfiles (package-lock/package.json versions), commit hash.

## Environment and security
- CORS: `ALLOWED_ORIGINS` required; `STRICT_CORS=true` to fail fast if unset.
- Rate limiting: public bundle endpoint guarded; configure Redis-backed limiter for production.
- Headers: `ENABLE_SECURITY_HEADERS=true` adds no-sniff, frame deny, referrer policy, HSTS (https only).
- Auth: replace mock user with JWT/OIDC in production.
- Static vkeys: served at `/zkp/artifacts/...` (cacheable, gzip recommended at proxy).

## Load test (target p99 < 200ms)
k6 script at `tests/perf/k6-load.js`:
```bash
BASE_URL=https://staging.yourdomain AUTH="Bearer ..." k6 run tests/perf/k6-load.js
```
Scenarios:
- Ramp: to 100 VUs, hold 5m.
- Spike: 10 -> 500 VUs instantly at t=9m.
Thresholds: `p(99)<200ms`, error rate <1%.

## ZAP / DAST
Baseline:

```bash
docker run --rm -t owasp/zap2docker-stable zap-baseline.py -t https://staging.yourdomain -r zap-baseline.html
```

Full:

```bash
docker run --rm -t -v $(pwd):/zap/wrk owasp/zap2docker-stable zap-full-scan.py -t https://staging.yourdomain -r zap-full.html
```

## Chaos drills
- Kill Redis (rate limiter) during load; expect graceful 429/503, auto-recovery when back.
- Kill Neo4j; expect health/readiness to show down, 503 on dependent routes, auto-reconnect on return.

## Deliverables to auditors
- This `AUDIT.md`
- Checksums of ptau/r1cs/zkey/vkey
- Sample valid proofs + public signals per circuit
- Environment config (CORS, auth, rate limits)
- API surface list and versions (circom/snarkjs/npm lockfile)
